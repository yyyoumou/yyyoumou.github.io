# Milestone: My First LeetCode Solution!

I know this might seem like simple work to some, but this is a massive milestone for me. I have finally worked out my **first** independent solution for a LeetCode problem! 

## Problem: 481. Magical String (Medium)

神奇字符串 `s` 仅由 `'1'` 和 `'2'` 组成，并需要遵守下面的规则：
将连续相同字符组 `'1'` 和 `'2'` 长度的序列连接起来会生成字符串 `s` 本身。

`s` 的前几个元素是 `s = "1221121221221121122……"` 。如果将 `s` 中连续的若干 1 和 2 进行分组，可以得到 `"1 22 11 2 1 22 1 22 11 2 11 22 ......"` 。每组中 1 或者 2 的出现次数分别是 `"1 2 2 1 1 2 1 2 2 1 2 2 ......"` 。上面的出现次数正是 `s` 自身。

**任务：** 给你一个整数 `n` ，返回在神奇字符串 `s` 的前 `n` 个数字中 `1` 的数目。

## My C++ Solution & Learning Notes

And here my solution:
```class Solution {
public:
    int magicalString(int n) {
       if(n<=0) return 0;
       if(n<=3) return 1;
 // 122  作为seed，后面开始生长
      string s="122";
//string 是字符串(cpp)也是动态数组，可以无限扩充，用双引号括起
     int head=2;
//从2开始生成，然后后面会转化为1，写判断语句while
while(s.length()<n){
    if(s.back()=='2'){
        char next_char='1';
        //push,转码，将s[head]从ascII码50-‘0’（48）转码成2
        for(int i=0;i<s[head]-'0';i++){
        s.push_back(next_char);}
    }
    else if(s.back()=='1'){
        char next_char='2';
        for(int i=0;i<s[head]-'0';i++){
        s.push_back(next_char);}
    }
    head++;
   
}
int count=0;
for(int i=0;i<n;i++){
    if(s[i]=='1'){
        count++;
    }
}
return count;
        }
};```
