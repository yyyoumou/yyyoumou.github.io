# I know this is just a simple work but this is really a milestone for me 
## I have worked out my **first** solution for leetcode 

Here are the title:
神奇字符串 s 仅由 '1' 和 '2' 组成，并需要遵守下面的规则：

将连续相同字符组 '1' 和 '2' 长度的序列连接起来会生成字符串 s 本身。
s 的前几个元素是 s = "1221121221221121122……" 。如果将 s 中连续的若干 1 和 2 进行分组，可以得到 "1 22 11 2 1 22 1 22 11 2 11 22 ......" 。每组中 1 或者 2 的出现次数分别是 "1 2 2 1 1 2 1 2 2 1 2 2 ......" 。上面的出现次数正是 s 自身。

给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。
示例 1：
输入：n = 6
输出：3
解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 
示例 2：
输入：n = 1
输出：1

And here my solution:
'''class Solution {
public:
    int magicalString(int n) {
       if(n<=0) return 0;
       if(n<=3) return 1;
 // 122  作为seed，后面开始生长
      string s="122";
//string 是字符串(cpp)也是动态数组，可以无限扩充，用双引号括起
     int head=2;
//从2开始生成，然后后面会转化为1，写判断语句while
while(s.length()<n){
    if(s.back()=='2'){
        char next_char='1';
        //push,转码，将s[head]从ascII码50-‘0’（48）转码成2
        for(int i=0;i<s[head]-'0';i++){
        s.push_back(next_char);}
    }
    else if(s.back()=='1'){
        char next_char='2';
        for(int i=0;i<s[head]-'0';i++){
        s.push_back(next_char);}
    }
    head++;
   
}
int count=0;
for(int i=0;i<n;i++){
    if(s[i]=='1'){
        count++;
    }
}
return count;
        }
};'''
